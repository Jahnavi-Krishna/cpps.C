Day 4 [ Learning Episodes]{Sum of n numbers}

(1)What is an array?
Array names are simply pointers to where the arrays begin in memory, and, of course,
two arrays will always be at different memory locations.
When an array is passed to a general-purpose function designed to handle arrays of
any size, the size of the array must be passed as an additional argument. Furthermore, one
array cannot be assigned to another with the assignment operator(s)—array names are
const pointers, so they cannot be used on the left side of an assignment operator.

pg 217
An array is a group of contiguous memory locations that all have the same type. To refer to
a particular location or element in the array, we specify the array’s name and the position
number of the particular element in the array.

(2)How to declare an array?
Any one of the elements may be referred to by giving the array’s name followed by the position number of
the particular element in square brackets ( [] ). The first element in every array is the zeroth
element. An array name, like other variable names, can contain only letters, digits and
underscores and cannot begin with a digit.
pg.218
eg.All elements of this array
share the array name, c
Position number of the
element within array c
Fig. 6.1 | 12-element array.
c[ 0 ] -45
c[ 1 ] 6
c[ 2 ] 0
c[ 3 ] 72
c[ 4 ] 1543
c[ 5 ] -89
c[ 6 ] 0
c[ 7 ] 62
c[ 8 ] -3
c[ 9 ] 1
c[ 10 ] 6453
c[ 11 ]
The position number within square brackets is called a subscript. A subscript must be
an integer or an integer expression.


(3)What is a pointer?

Pointers are variables whose values are memory addresses. Normally, a variable directly con-
tains a specific value. A pointer, on the other hand, contains an address of a variable that
contains a specific value. In this sense, a variable name directly references a value, and a
pointer indirectly references a value (Fig. 7.1). Referencing a value through a pointer is
called indirection.
pg.278
Declaring Pointers
Pointers, like all variables, must be defined before they can be used. The definition specifies that variable countPtr is of type int * (i.e., a pointer to an integer) and is read
(right to left), “ countPtr is a pointer to int ” or “ countPtr points to an object of type int .”
Also, the variable count is defined to be an int , not a pointer to an int . The * applies only to countPtr in the definition. 
When * is used in this manner in a definition, it indicates that the variable being defined is a pointer. 
Pointers can be defined to point to objects of any type. 
To prevent the ambiguity of declaring pointer and non-pointer variables in the same declaration as shown above,
you should always declare only one variable per declaration.

int *countPtr, count;

Note: Pointers and pointer-based entities such as arrays and strings, when misused intentionally or acciden-
tally, can lead to errors and security breaches. See our Secure C Programming Resource Center
( www.deitel.com/SecureC/ ) for articles, books, white papers and forums on this important topic.7.3 Pointer Operators
279
count
7
countPtr
count
7
The name count directly references
a variable that contains the value 7
The pointer countPtr indirectly
references a variable that
contains the value 7

(4)Adding n numbers without using array:

#include<stdio.h>

int main()
{
int val,sum=0,n;

printf("Enter the number of entries you want to add\n");
scanf("%d",&n);

printf("Enter the values\n");

for(int i=0;i<n;i++)
{
scanf("%d",&val);
sum+=val;
}
printf("The total sum is =%d",sum);
}


sum.c: In function ‘main’:
sum.c:10:1: error: stray ‘\’ in program
 printf("Enter the values"\n);
 ^
sum.c:10:27: error: expected ‘)’ before ‘n’
 printf("Enter the values"\n);
                           ^
sum.c:18:1: error: expected declaration or statement at end of input
 }
 ^
 __\n should be declared before terminating the " ;
 
 (5)
 
 sum.c: In function ‘main’:
sum.c:18:1: error: expected declaration or statement at end of input
 }
 ^
The last } was not terminated.Got confused with the terminating bracket of the loop.Typo error.
 
 
 (6)What is Recursion?
 A recursive function is a function that calls itself either directly or indirectly through another function.
pg.188
 A recursive function is called to solve a problem. The function actually knows how to solve only the simplest case(s), or so-called base case(s).
If the function is called with a base case, the function simply returns a result. If the function is called with a more complex problem,
the function divides the problem into two conceptual pieces: a piece that the function knows how to do and a piece that it does not know how to do.
To make recursion feasible, the latter piece must resemble the original problem, but be a slightly simpler or smaller version.
Because this new problem looks like the original problem, the function launches (calls) a fresh copy of itself to go to work on
the smaller problem—this is referred to as a recursive call or the recursion step. The recursion step also includes the keyword return ,
because its result will be combined with the portion of the problem the function knew how to solve to form a result that will be passed 
back to the original caller.The recursion step executes while the original call to the function has not yet finished executing. 
The recursion step can result in many more such recursive calls, as the function keeps dividing each problem it’s called with into two conceptual pieces.
For the recursion to terminate, each time the function calls itself with a slightly simpler version of the original problem, 
this sequence of smaller problems must eventually converge on the base case.When the function recognizes the base case,
it returns a result to the previous copy of the function, and a sequence of returns ensues all the way up the line until the original call of
the function eventually returns the final result to main . All of this sounds quite exotic compared to the kind of problem solving we’ve been using with 
conventional function calls to this point. It can take a great deal of practice writing recursive programs before the process
will appear natural. As an example of these concepts at work, let’s write a recursive program to perform a popular mathematical calculation.


(7)Using arrray
#include<stdio.h>
int main()
{
        int n,sum;
        printf("How many numbers do you want to add?\n");
        scanf("%d",&n);
        int b[n]=input();
        sum=compute();
        output(sum);
}



int input()
{
        printf("Enter the values\n");
        for(int i=0;i<n;i++)
        {
                scanf("%d",b[i]);
        }
        return b[n];
}

int compute()
{
        int s;
        for(int i;i<n;i++)
                s+=b[i];
        return s;
}



int output(int sum)
{
        printf("The total sum is =%d",sum);
}





sum.c: In function ‘main’:
sum.c:7:2: error: variable-sized object may not be initialized
  int b[n]=input();
  ^
sum.c:7:11: warning: implicit declaration of function ‘input’ [-Wimplicit-function-declaration]
  int b[n]=input();
           ^
sum.c:8:6: warning: implicit declaration of function ‘compute’ [-Wimplicit-function-declaration]
  sum=compute();
      ^
sum.c:9:2: warning: implicit declaration of function ‘output’ [-Wimplicit-function-declaration]
  output(sum);
  ^
sum.c: In function ‘input’:
sum.c:17:16: error: ‘n’ undeclared (first use in this function)
  for(int i=0;i<n;i++)
                ^
sum.c:17:16: note: each undeclared identifier is reported only once for each function it appears in
sum.c:19:14: error: ‘b’ undeclared (first use in this function)
   scanf("%d",b[i]);
              ^
sum.c: In function ‘compute’:
sum.c:27:14: error: ‘n’ undeclared (first use in this function)
  for(int i;i<n;i++)
              ^
sum.c:28:6: error: ‘b’ undeclared (first use in this function)
   s+=b[i];
      ^
      
      
      
 (8)sum.c: In function ‘main’:
sum.c:7:9: error: variable-sized object may not be initialized
         int b[n]=input();
         ^
sum.c:7:18: warning: implicit declaration of function ‘input’ [-Wimplicit-function-declaration]
         int b[n]=input();
                  ^
sum.c:8:13: warning: implicit declaration of function ‘compute’ [-Wimplicit-function-declaration]
         sum=compute();
             ^
sum.c:9:9: warning: implicit declaration of function ‘output’ [-Wimplicit-function-declaration]
         output(sum);
         ^
sum.c: In function ‘input’:
sum.c:17:23: error: ‘n’ undeclared (first use in this function)
         for(int i=0;i<n;i++)
                       ^
sum.c:17:23: note: each undeclared identifier is reported only once for each function it appears in
sum.c:19:28: error: ‘b’ undeclared (first use in this function)
                 scanf("%d",b[i]);
                            ^
sum.c: In function ‘compute’:
sum.c:27:21: error: ‘n’ undeclared (first use in this function)
         for(int i;i<n;i++)
                     ^
sum.c:28:20: error: ‘b’ undeclared (first use in this function)
                 s+=b[i];
                    ^
sum.c: At top level:
sum.c:38:3: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘+=’ token
  s+=b[i];
   ^
sum.c:39:2: error: expected identifier or ‘(’ before ‘return’
  return s;
  ^
sum.c:40:1: error: expected identifier or ‘(’ before ‘}’ token
 }
 ^
sum.c:44:5: error: redefinition of ‘output’
 int output(int sum)
     ^
sum.c:34:5: note: previous definition of ‘output’ was here
 int output(int sum)
     ^
     
