(1) WHat are the diffeerent ways to debug a logical error?

1.Comparing with a existing program which works
        problem:it is a strategy to learn a prg nd not programming
2. Is mental tracing a good stategy?
        problrm:if your understanding of particulara set of concepts may be incomplete,thus u might trace wrong.
3.putting printf where ever possible
        -v can find the control flow (whether it is going to if part or else part,like if it goes to the if part,printing "if part" etc)
        -values of the variables can be printed
        (thereis something called logging in large prgs to debug logical errors.)
4.Single stepping
        to debug,compile with the flag -g
  gcc -g prgname.c
  ->ddd =data display debugger.
ddd ./a.out



(2)
int input(int *a,int *b)
{
        printf("Enter a\n");
        scanf("%d",a);
        printf("Enter b\n");
        scanf("%d",b);
}
int compare(int m,int n)
{
        int p;
        if(m=n)
                p=00;
        else
        {
                if(m>n)
                        p=m;
                else if(n>m)
                        p=n;
        }
}
void output(int m,int n,int p)
{
        if(p=00)
                printf("Both are equal");
        else
                printf("%d is greater among %d and %d",&p,&m,&n);
}
int main()
{
}
compare.c: In function ‘output’:
compare.c:27:10: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘int *’ [-Wformat=]
   printf("%d is greater among %d and %d",&p,&m,&n);
          ^
compare.c:27:10: warning: format ‘%d’ expects argument of type ‘int’, but argument 3 has type ‘int *’ [-Wformat=]
compare.c:27:10: warning: format ‘%d’ expects argument of type ‘int’, but argument 4 has type ‘int *’ [-Wformat=]
____used *a,*b,maybe thats wrong
The same error appeared 
___maybe I should ude if(p==00)
Same error again
declaration and the indentation was not right.




(3)compare.c: In function ‘output’:
compare.c:28:10: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘int *’ [-Wformat=]
   printf("%d is greater among %d and %d",&q,&r,&s);
          ^
compare.c:28:10: warning: format ‘%d’ expects argument of type ‘int’, but argument 3 has type ‘int *’ [-Wformat=]
compare.c:28:10: warning: format ‘%d’ expects argument of type ‘int’, but argument 4 has type ‘int *’ [-Wformat=]
compare.c: In function ‘main’:
compare.c:32:7: error: expected identifier or ‘(’ before ‘int’
 int x,int y,int z;
       ^
compare.c:33:11: error: ‘y’ undeclared (first use in this function)
 input(&x,&y);
           ^
compare.c:33:11: note: each undeclared identifier is reported only once for each function it appears in
compare.c:34:1: error: ‘z’ undeclared (first use in this function)
 z=compare(x,y);
 ^
___Declaration was not correct,and indentation of main function was wrong.





(4)What is a Right shift operator(>>)? 
I know it is not the same as > because '>' is greater than symbol used for comparing .
where as '>>' is something called right shift operator.
__I guess this operator shifts the value or memory location to the right position.
pg425
The right-shift operator ( >> ) shifts the bits of its left operand to the right by the number
of bits specified in its right operand. Performing a right shift on an unsigned int causes
the vacated bits at the left to be replaced by 0 s; 1 s shifted off the right are lost. In
Fig. 10.13, the result of right shifting number1 in the expression number1 >> 8 (line 21) is
3 ( 00000000 00000000 00000000 00000011 ).





(5)compare.c: In function ‘output’:
compare.c:29:10: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘int *’ [-Wformat=]
   printf("%d is greater among %d and %d",&q,&r,&s);
          ^
compare.c:29:10: warning: format ‘%d’ expects argument of type ‘int’, but argument 3 has type ‘int *’ [-Wformat=]
compare.c:29:10: warning: format ‘%d’ expects argument of type ‘int’, but argument 4 has type ‘int *’ [-Wformat=]

__syntax errors, variables were mismatched.

#include<stdio.h>
int input(int*a,int*b)
{
        printf("Enter the first number\n");
        scanf("%d",a);
        printf("Enter thr second number\n");
        scanf("%d",b);
}
int compare(int m,int n)
{
        int p;
        if(m==n)
                p=00;

        else
        {
                if(m>n)
                        p=m;

                else(n>m)
                        p=n;

        }
        return p;
}
void output(int q,int r,int s)
{
        if(s==00)
                printf("Both are equal");

        else
                printf("%d is greater among %d and %d",s,r,q);

}
int main()
{
        int x,y,z;
        input(&x,&y);
        z=compare(x,y);
        output(x,y,z);
}









(6)ERROR:
compare.c: In function ‘compare’:
compare.c:20:4: error: expected ‘;’ before ‘p’
    p=n;
    ^
    __used a condition for else,
    either else if should be used to have a condition or else should be used .
    
    correct codde::
    #include<stdio.h>
int input(int*a,int*b)
{
        printf("Enter the first number\n");
        scanf("%d",a);
        printf("Enter thr second number\n");
        scanf("%d",b);
}
int compare(int m,int n)
{
        int p;
        if(m==n)
                p=00;

        else
        {
                if(m>n)
                        p=m;
                else
                        p=n;
        }
        return p;
}
void output(int q,int r,int s)
{
        if(s==00)
                printf("Both are equal");

        else
                printf("%d is greater among %d and %d",s,r,q);

}
int main()
{
        int x,y,z;
        input(&x,&y);
        z=compare(x,y);
        output(x,y,z);
}




(7)What is a Left shift operator(<<)? 
I know it is not the same as < because '<' is lesser than symbol used for comparing .
where as '<<' is something called left shift operator.
__I guess this operator shifts the value or memory location towards the left position .
pg425
The left-shift operator ( << ) shifts the bits of its left operand to the left by the number
of bits specified in its right operand. Bits vacated to the right are replaced with 0 s; 1 s
shifted off the left are lost. In Fig. 10.13, variable number1 is assigned the value 960
( 00000000 00000000 00000011 11000000 ) in line 9. The result of left shifting variable
number1 8 bits in the expression number1 << 8 (line 15) is 49152 ( 00000000 00000011
11000000 00000000 ).
